# swig-101

Introduction to [SWIG](http://www.swig.org/).

# What is SWIG?

SWIG is a foreign-function-interface (FFI) generator for native C/C++.
SWIG vastly reduces the development cost of using native libraries within dynamic languages.

# History

* SWIG was [created](https://www.swig.org/history.html) in 1995 at Los Alamos National Laboratory.
* Still under active development.

# Benefits

SWIG:

* parses SWIG interface definition files.
* SWIG interface defintions are a superset of C/C++.
* many C/C++ header files can be used verbatim with minimal specification.
* interface definitions can target multiple target languages with little additional effort.
* genertated FFI code is statically-generated, reducing runtime costs.
* FFI code can be dynamically loaded or statically linked.
* FFI code is self-contained.
* hinting for improved integration and representation.
* template driven, user's can write generator for multiple purposes.

# Native Code Support

Comprehensive support:

** C struct/unions
** C pointers
** C function signatures
** C function calls
** C++ classes
** C++ methods: static, virtual and operator override
** Pointers, References, `const` declarations. 
** `in`, `out`, `in-out` parameter declarations.
** Memory Management

# Target Languages

SWIG can generate FFI bindings for many languages from one set of interface files:

* D
* Go
* Guile
* Java
* Javascript
* Lua
* Octave
* Perl 5
* PHP 7
* Python
* R (aka GNU S)
* Ruby
* Scilab
* Tcl 8
* XML (machine-readable metadata)

# Alternatives

## Native Language ABIs

* Every native language's ABI is entirely different.
* Some implementations of the same target language have different ABIs: e.g. JRuby and CRuby.
* Some are only dynamic with associate performance costs.
* Few languages have well-defined ABIs; Java JNI is a notable exception.
* Each ABI requires intimate knownlege of internals ABIs and rules:
** class and method definition
** memory managment
** best-practices

## LibFFI

[Libffi](https://github.com/libffi/libffi) can invoke native C functions dynamically from a low-level function signature.

* libffi does not interpret native C/C++ headers.
* C++ FFI is unsupported.
* Must explicit specfify function signatures at [runtime](http://www.chiark.greenend.org.uk/doc/libffi-dev/html/Simple-Example.html).
* Does not provide any data type serialization functionality.  
* Must have knowlege of CPU and compiler calling conventions.
* Must manually layout struct and union values accordingly.

# Case Study


| Kind         |   Language     | files | lines |
-------------+-------+--------------------------|
| Native C/C++ Library | | |
|  | C/C++ Header |   626 |  150508 |
|  | C++          |   254 |   91226 |
|  | TOTAL:     |   880 |  241734 |
| SWIG Interface Files | | |
| | SWIG         |     9  |    2667 |
| Generated Python FFI Files | | |
| | C++          |    1     34983 |
| Generate Java FFI Files | | |
| | C++          |   1   |  17987 |
| | Java         |  55   |   6741 |
| | TOTAL:       | 56    |  24728 |

# Examples

The examples below target these languages:

* Python
* Ruby
* TCL
* Guile Scheme
* Clojure via Java

<%
exit! if ENV['README_MD']
ENV['README_MD'] = '1'

require 'pp'

$verbose = false
$pe  = $verbose # || true
$msg = $verbose # || true

def msg *args
  if $msg
    $stderr.puts "\n  !!! #{$$} : README.md.erb : #{args * ' '}"
  end
end

def pe x
  if $verbose or $pe
    PP.pp(x, $stderr)
    $stderr.flush
  end
  x
end

def cmd cmd
  msg "cmd : #{cmd.inspect}"
  system "bin/run #{cmd} >tmp/cmd.out 2>&1"
  File.read("tmp/cmd.out")
end

def string_lines s
  s.
  split("\n", -1).
  tap{|lines| lines.each{|line| line.sub!(/\s+$/, '')}}.
  tap{|lines| lines.shift while lines[0].empty?}.
  tap{|lines| lines.pop   while lines[-1].empty?}.
  map.with_index(1) {|line, i| "%3d   %s" % [i, line] }.
  join("\n") + "\n"
end

def wrap_line line, width = 78
  words = line.strip.split(/\s+/)
  out = String.new
  line = String.new
  words.each do | word |
    if line.size + word.size > width
      out += line + " \\\n  "
      line = String.new
    end
    line += word + ' '
    # pe(word: word, words: words)
  end
  out << line
end

def run_workflow e
  # cmd "#{make} clean-example EXAMPLE=#{e[:name]}"
  cmd "#{make} clean"
  out = cmd "#{make} build-example EXAMPLE=#{e[:name]}"
  # pe(s: out)
  out = out.
  gsub('/opt/local/bin/gmake', 'make').
  gsub(%r{^/.*/swig}, 'swig').
  gsub(%r{/Library/Java/JavaVirtualMachines/jdk.+?jdk/Contents/Home}, '$JAVA_HOME').
  gsub(%r{/opt/local/Library/Frameworks/Python.framework/Versions/[^/]+}, '$PYTHON_HOME').
  gsub(%r{-isysroot/Library/Developer/CommandLineTools/SDKs/.+?.sdk}, ' ').
  gsub(%r{^/.*/python}, 'python').
  gsub(%r{ *-I */opt/local/include[^ ]* *}, ' ').
  gsub(%r{ *-L */opt/local/lib[^ ]* *}, ' ').
  gsub(%r{#{ENV['PYTHON_HOME']}}, '$PYTHON_HOME').
  gsub(%r{#{ENV['RUBY_HOME']}}, '$RUBY_HOME').
  gsub(%r{#{ENV['GUILE_HOME']}}, '$GUILE_HOME').
  gsub(%r{#{ENV['JAVA_HOME']}}, '$JAVA_HOME').
  gsub(%r{#{ENV['HOME']}}, '$HOME').
  gsub(%r{  +}, ' ')
  lines = out.split("\n", 999999)
  lines.reject!{|l| l =~ /Deprecated command line option/} # swig 4.1.0+
  lines.reject!{|l| l =~ /Document-method:/ } # ruby
  # pe(lines: lines)
  lines.map{|l| wrap_line(l.gsub(%r{  +}, ' '))}.join("\n")
end

def make
  # make = `which gmake make 2>/dev/null`.split("\n").first
  'bin/build'
end

#####################################

msg "Start"

examples = [ ]
targets = nil

#####################################

cmd "#{make} all >/dev/null"
%>

<%
msg "Examples"

%w(example1.c example2.cc).each do | name |
  src       = "src/#{name}"
  basename  = name.sub(/\.([^.]+)$/, '')
  suffix    = $1
  lang = suffix.upcase
  examples << (e = {
    name:     name,
    basename: basename,
    src:      src,
    suffix:   suffix,
    lang:     lang,
  })

  msg "{{{ Example : #{e[:name]}"
  pe(e: e)

  targets = <<"END".split("\n").map{|l| l.split("|").map(&:strip).reject(&:empty?)}
#{lang} Header          | src/#{basename}.h        | -
#{lang} Library         | src/#{name}              | -
#{lang} Main            | src/#{basename}-native.#{suffix} | target/native/#{basename}
#{lang} SWIG Interface  | src/#{basename}.i        | -
Ruby                    | src/#{basename}-ruby     | 
Python                  | src/#{basename}-python   |
TCL                     | src/#{basename}-tcl      |
Guile                   | src/#{basename}-guile    |
Clojure                 | src/#{basename}-clojure  |
END

  targets =
    targets.
    map do |l|
      t = [:type, :file, :cmd].zip(l).to_h
      t[:name] ||= t[:file]
      if t[:cmd] == '-'
        t[:cmd] = nil
      else 
        t[:cmd] ||= t[:file]
      end
      t
    end

  pe(targets: targets)
%>

# <%= basename.capitalize %>

<% targets.each do | t |
  msg "{{{ Example : #{e[:name]} : Program : #{t[:name]}"
%>
## <%= t[:type] %> : <%= t[:file] %>

``` <%= t[:type].split(" ").first %>
<%=
string_lines(File.read(t[:file]))
%>
```

<% if t[:cmd] %>
----

```
$ <%= t[:cmd] %>
<%= cmd t[:cmd] %>
```
<% end %>
<%
  msg "}}} Example : #{e[:name]} : Program : #{t[:name]}"
end
%>

## Output
<%
msg "{{{ Output"
targets.select{|t| t[:cmd]}.each do | t |
  msg "#{e[:name]} : #{t[:name]} : Output : {{{"
%>

```
$ <%= t[:cmd] %>
<%= cmd t[:cmd] %>
```

<%
  msg "}}} Example : #{e[:name]} : Output : #{t[:name]}"
end
%>
<%
  msg "}}} Example : #{e[:name]}"
end
msg "}}} Output"
%>

# Workflow

<% msg "{{{ Workflow" %>

<%=
workflow = File.read("doc/workflow.txt")
if ENV['MARKDEEP']
  workflow
else
  workflow.
    gsub(/^\* /, '').
    gsub(/^\*\*\*+\s*$/, '```')
end 
%>

<%
examples.each do | e |
%>
<%= run_workflow e %>
<%
  msg "}}} Workflow : #{e[:name]}"
end
%>
<%
msg "}}} Workflow"
cmd "#{make} all >/dev/null"
msg 'DONE'
%>

# HOW-TO

## Setup

* Install rbenv + ruby-build
* rbenv install 2.7.1
* Install JVM 11.0
* Install clojure + clojure-tools

### Debian (Ubuntu 18.04+)

* Install a Python 3.10 distribution with python3.10 in $PATH.
* Run `bin/build debian-prereq`

### OSX

* Install macports
* Run `bin/build macports-prereq`

## Build

```
$ rbenv shell 2.7.1
$ bin/build clean demo
```
