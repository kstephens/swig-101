# SWIG-101

Introduction to [SWIG](http://www.swig.org/).

# What is SWIG?

SWIG is a foreign-function-interface (FFI) generator for native C/C++ libraries.
SWIG vastly reduces the development cost of using native libraries within dynamic languages.

# History

* SWIG was [created](https://www.swig.org/history.html) in 1995 at Los Alamos National Laboratory.
* Still under active development.

# Benefits

SWIG:

* Parses SWIG interface definition files.
* SWIG interface defintions are a superset of C/C++.
* Many C/C++ header files can be used verbatim with minimal specification.
* Interface definitions can target multiple target languages with little additional effort.
* Generated FFI code is statically-generated, reducing runtime costs.
* FFI code can be dynamically loaded or statically linked.
* FFI code is self-contained.
* Hinting for improved integration and representation.
* Template driven, user's can write generator for multiple purposes.
* Use dynamic language to test C/C++ code.

# Native Code Support

Comprehensive support:

* C struct and union
* C/C++ Pointers, references, `const` declarations
* C/C++ function signatures and calls
* C++ classes
* C++ methods: static, virtual and operator overrides
* C++ templates
* `in`, `out`, `in-out` parameters
* C/C++ `#define` macros
* Memory Management

# Target Languages

SWIG can generate FFI bindings for multiple target languages from one set of interface files:

* Python
* Ruby
* Java
* Perl 5
* Tcl 8
* Lua
* D
* Go
* Guile Scheme
* Javascript
* Octave
* PHP 7
* R (aka GNU S)
* Scilab
* XML (machine-readable metadata)

# Alternatives

## Rewrite it in Language X

* Coders love greenfields.
* Waste of time.

## Native Language ABIs

* Every native language's ABI is entirely different.
* Some implementations of the same target language have different ABIs: e.g. JRuby and CRuby.
* Some are only dynamic with associate performance costs.
* Few languages have well-defined ABIs; Java JNI is a notable exception.
* Each ABI requires intimate knownlege of ABIs
 * rules
 * best-practices
 * manual data structure, function, class, method wrapping and registration
 * manual memory managment

## LibFFI

[Libffi](https://github.com/libffi/libffi) can invoke native C functions dynamically from a low-level function signature.

* libffi does not interpret C/C++ headers.
* C++ FFI is unsupported.
* Must specify function signatures at [runtime](http://www.chiark.greenend.org.uk/doc/libffi-dev/html/Simple-Example.html).
* Does not provide any data type serialization functionality.
* Must have knowledge of CPU, Compiler and OS calling conventions.
* Must manually layout struct and union values accordingly.

# Case Study

Kind              |  Language     |  Files  |   Lines 
------------------|:-------------:|--------:|----------:
Native C/C++      |               |         |  
                  | C/C++ Header  |      40 |    3505
SWIG Interfaces   |               |         |
                  | SWIG          |       9 |    2667
Generated Python  |               |         |
                  | Python        |       1 |    8922
                  | C++           |       1 |   35235
Generated Java    |               |         | 
                  | Java          |      55 |    6741
                  | C++           |       1 |   17987

# Examples

The examples below target:

* Python
* Clojure via Java
* Ruby
* TCL
* Guile Scheme

<%
exit! if ENV['README_MD']
ENV['README_MD'] = '1'

require 'pp'

$verbose = false
$pe  = $verbose # || true
$msg = $verbose # || true

def msg *args
  if $msg
    $stderr.puts "\n  !!! #{$$} : README.md.erb : #{args * ' '}"
  end
end

def pe x
  if $verbose or $pe
    PP.pp(x, $stderr)
    $stderr.flush
  end
  x
end

def cmd cmd
  msg "cmd : #{cmd.inspect}"
  system "bin/run #{cmd} >tmp/cmd.out 2>&1"
  File.read("tmp/cmd.out")
end

def string_lines s
  s.
  split("\n", -1).
  tap{|lines| lines.each{|line| line.sub!(/\s+$/, '')}}.
  tap{|lines| lines.shift while lines[0].empty?}.
  tap{|lines| lines.pop   while lines[-1].empty?}.
  map.with_index(1) {|line, i| "%3d   %s" % [i, line] }.
  join("\n") + "\n"
end

def wrap_line line, width = 78
  words = line.strip.split(/\s+/)
  out = String.new
  line = String.new
  words.each do | word |
    if line.size + word.size > width
      out += line + " \\\n  "
      line = String.new
    end
    line += word + ' '
    # pe(word: word, words: words)
  end
  out << line
end

def run_workflow e
  # cmd "#{make} clean-example EXAMPLE=#{e[:name]}"
  cmd "#{make} clean"
  out = cmd "#{make} build-example EXAMPLE=#{e[:name]}"
  # pe(s: out)
  out = out.
  gsub('/opt/local/bin/gmake', 'make').
  gsub(%r{^/.*/swig}, 'swig').
  gsub(%r{/Library/Java/JavaVirtualMachines/jdk.+?jdk/Contents/Home}, '$JAVA_HOME').
  gsub(%r{/opt/local/Library/Frameworks/Python.framework/Versions/[^/]+}, '$PYTHON_HOME').
  gsub(%r{-isysroot/Library/Developer/CommandLineTools/SDKs/.+?.sdk}, ' ').
  gsub(%r{^/.*/python}, 'python').
  gsub(%r{ *-I */opt/local/include[^ ]* *}, ' ').
  gsub(%r{ *-L */opt/local/lib[^ ]* *}, ' ').
  gsub(%r{#{ENV['PYTHON_HOME']}}, '$PYTHON_HOME').
  gsub(%r{#{ENV['RUBY_HOME']}}, '$RUBY_HOME').
  gsub(%r{#{ENV['GUILE_HOME']}}, '$GUILE_HOME').
  gsub(%r{#{ENV['JAVA_HOME']}}, '$JAVA_HOME').
  gsub(%r{#{ENV['HOME']}}, '$HOME').
  gsub(%r{  +}, ' ')
  lines = out.split("\n", 999999)
  lines.reject!{|l| l =~ /Deprecated command line option/} # swig 4.1.0+
  lines.reject!{|l| l =~ /Document-method:/ } # ruby
  # pe(lines: lines)
  lines.map{|l| wrap_line(l.gsub(%r{  +}, ' '))}.join("\n")
end

def make
  # make = `which gmake make 2>/dev/null`.split("\n").first
  'bin/build'
end

#####################################

msg "Start"

examples = [ ]
targets = nil

#####################################

cmd "#{make} all >/dev/null"
%>

<%
msg "Examples"

%w(polynomial.cc example1.c).each do | name |
  src       = "src/#{name}"
  basename  = name.sub(/\.([^.]+)$/, '')
  suffix    = $1
  lang = suffix.upcase
  examples << (e = {
    name:     name,
    basename: basename,
    src:      src,
    suffix:   suffix,
    lang:     lang,
  })

  msg "{{{ Example : #{e[:name]}"
  pe(e: e)

  targets = <<"END".split("\n").map{|l| l.split("|").map(&:strip).map{|f| f.empty? ? nil : f}}
#{lang} Header          | src/#{basename}.h        | - |
#{lang} Library         | src/#{name}              | - |
#{lang} Main            | src/#{basename}-native.#{suffix} | target/native/#{basename}
#{lang} SWIG Interface  | src/#{basename}.i        | - | #{lang}
Python                  | src/#{basename}-python   |   |
Clojure (Java)          | src/#{basename}-clojure  |   | Lisp
Ruby                    | src/#{basename}-ruby     |   |
Guile                   | src/#{basename}-guile    |   | Scheme
TCL                     | src/#{basename}-tcl      |   |
END
  targets =
    targets.
    map do |l|
      t = [:type, :file, :cmd, :lang].zip(l).to_h
      t[:name] ||= t[:file]
      if t[:cmd] == '-'
        t[:cmd] = nil
      else 
        t[:cmd] ||= t[:file]
      end
      t[:lang] ||= t[:type].split(/\s+/).first
      t
    end

  # PP.pp(targets: targets, $stderr)
  pe(targets: targets)
%>

# <%= basename.capitalize %>

<% targets.each do | t |
  msg "{{{ Example : #{e[:name]} : Program : #{t[:name]}"
%>
## <%= t[:type] %> : <%= t[:file] %>

```<%= t[:lang] %>
<%=
string_lines(File.read(t[:file]))
%>
```

<% if t[:cmd] %>
----

```
$ <%= t[:cmd] %>
<%= cmd t[:cmd] %>
```
<% end %>
<%
  msg "}}} Example : #{e[:name]} : Program : #{t[:name]}"
end
%>

## Output
<%
msg "{{{ Output"
targets.select{|t| t[:cmd]}.each do | t |
  msg "#{e[:name]} : #{t[:name]} : Output : {{{"
%>

```
$ <%= t[:cmd] %>
<%= cmd t[:cmd] %>

```

<%
  msg "}}} Example : #{e[:name]} : Output : #{t[:name]}"
end
%>
<%
  msg "}}} Example : #{e[:name]}"
end
msg "}}} Output"
%>

# Workflow

<% msg "{{{ Workflow" %>

<%=
workflow = File.read("doc/workflow.txt")
if ENV['MARKDEEP']
  workflow
else
  workflow.
    gsub(/^\* /, '').
    gsub(/^\*\*\*+\s*$/, '```')
end 
%>

<%
examples.each do | e |
%>
<%= run_workflow e %>
<%
  msg "}}} Workflow : #{e[:name]}"
end
%>
<%
msg "}}} Workflow"
cmd "#{make} all >/dev/null"
msg 'DONE'
%>

# HOW-TO

## Setup

* Install rbenv + ruby-build
* rbenv install 2.7.1
* Install JVM 11.0
* Install clojure + clojure-tools

### Debian (Ubuntu 18.04+)

* Install a Python 3.10 distribution with python3.10 in $PATH.
* Run `bin/build debian-prereq`

### OSX

* Install macports
* Run `bin/build macports-prereq`

## Build

```
$ rbenv shell 2.7.1
$ bin/build clean demo
```
